// frontend/src/hooks/useContentGeneration.ts\n/**\n * useContentGeneration Hook\n * Manages content generation requests and state\n */\n\nimport { useState, useCallback } from 'react'\nimport { apiClient } from '../utils/api'\n\ninterface GenerationResponse {\n  job_id: string\n  content_id?: string\n  session_id: string\n  status: string\n  message: string\n  ws_url: string\n}\n\nexport const useContentGeneration = () => {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [data, setData] = useState<GenerationResponse | null>(null)\n\n  const generateContent = useCallback(async (formData: any): Promise<GenerationResponse> => {\n    setLoading(true)\n    setError(null)\n\n    try {\n      const response = await apiClient.post('/v1/generate', {\n        source_url: formData.source_url,\n        source_type: formData.source_type,\n        content_types: formData.content_types,\n        tone: formData.tone,\n        target_audience: formData.target_audience || undefined,\n        include_hashtags: formData.include_hashtags,\n        include_emojis: formData.include_emojis,\n      })\n\n      setData(response.data)\n      return response.data\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : 'Failed to generate content'\n      setError(errorMessage)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  return { generateContent, loading, error, data }\n}\n\n// ============================================================================\n// useWebSocket Hook\n// ============================================================================\n\nexport const useWebSocket = (sessionId?: string) => {\n  const [message, setMessage] = useState<any>(null)\n  const [isConnected, setIsConnected] = useState(false)\n\n  const connect = useCallback((sid: string) => {\n    if (!sid) return\n\n    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws'\n    const wsUrl = `${protocol}://${window.location.host}/ws/process/${sid}`\n\n    const ws = new WebSocket(wsUrl)\n\n    ws.onopen = () => {\n      console.log('âœ… WebSocket connected')\n      setIsConnected(true)\n    }\n\n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data)\n        setMessage(data)\n        console.log('ðŸ“¨ WebSocket message:', data)\n      } catch (err) {\n        console.error('Failed to parse WebSocket message:', err)\n      }\n    }\n\n    ws.onerror = (error) => {\n      console.error('âŒ WebSocket error:', error)\n      setIsConnected(false)\n    }\n\n    ws.onclose = () => {\n      console.log('ðŸ“´ WebSocket disconnected')\n      setIsConnected(false)\n    }\n\n    return ws\n  }, [])\n\n  return { message, isConnected, connect }\n}\n\n// ============================================================================\n// useLocalStorage Hook\n// ============================================================================\n\nexport const useLocalStorage = <T,>(\n  key: string,\n  initialValue: T\n): [T, (value: T | ((val: T) => T)) => void] => {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    if (typeof window === 'undefined') return initialValue\n\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? JSON.parse(item) : initialValue\n    } catch (error) {\n      console.error('Failed to read from localStorage:', error)\n      return initialValue\n    }\n  })\n\n  const setValue = (value: T | ((val: T) => T)) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value\n      setStoredValue(valueToStore)\n\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(key, JSON.stringify(valueToStore))\n      }\n    } catch (error) {\n      console.error('Failed to write to localStorage:', error)\n    }\n  }\n\n  return [storedValue, setValue]\n}\n\n// ============================================================================\n// useAsync Hook\n// ============================================================================\n\ninterface UseAsyncState<T> {\n  status: 'idle' | 'pending' | 'success' | 'error'\n  data: T | null\n  error: Error | null\n}\n\nexport const useAsync = <T, E = string>(\n  asyncFunction: () => Promise<T>,\n  immediate = true\n) => {\n  const [state, setState] = useState<UseAsyncState<T>>({\n    status: 'idle',\n    data: null,\n    error: null,\n  })\n\n  const execute = useCallback(async () => {\n    setState({ status: 'pending', data: null, error: null })\n    try {\n      const result = await asyncFunction()\n      setState({ status: 'success', data: result, error: null })\n      return result\n    } catch (error) {\n      setState({\n        status: 'error',\n        data: null,\n        error: error instanceof Error ? error : new Error(String(error)),\n      })\n    }\n  }, [asyncFunction])\n\n  React.useEffect(() => {\n    if (immediate) {\n      execute()\n    }\n  }, [execute, immediate])\n\n  return { ...state, execute }\n}\n